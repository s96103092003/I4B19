<!DOCTYPE html>
<html>

<head>
    <style>
    </style>
</head>

<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js">
    </script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js">
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
    <script src="./MTLLoader.js"></script>
    <script src="./OBJLoader.js"></script>

    <script>
        var keyboard = new KeyboardState();
        var renderer, camera, camera2, controls, controls2, scene, axes;
        var clock;

        var pos = new THREE.Vector3();
        var speed = 0, angle = 0, vel;
        var car;
        var obstacle;
        var gridXZ;
        var spotLight;
        var spotLightShadowHelper;
        var spotLightHelper;
        var k = 0, sign = 1;
        (function () {
            Math.clamp = function (val, min, max) {
                return Math.min(Math.max(val, min), max);

            }
        })();
        init();
        animate();

        function buildTank() {
            var mtlLoader = new THREE.MTLLoader();
            //mtlLoader.setBaseUrl("???")//设置材质路径
            //mtlLoader.setPath("???")//设置mtl文件所在路径
            //mtlLoader.load(filename,onSuccess(materials ),onProgress(xhr),onError(error))：mtl文件名、 加载成功后回调处理(参数为生成的材质库)、加载过程中回调处理(xhr对象属性可计算出已完成加载百分比)、失败回调处理
            //objLoader.setMaterials( materials )//设置obj使用的材质贴图
            //objLoader.setPath( options.objPath )//设置obj文件所在路径
            //objLoader.load( filename,onSuccess(object ),onProgress(xhr),onError(error))：obj文件名、 加载成功后回调处理(参数为生成的三维对象)、加载过程中回调处理(xhr对象属性可计算出已完成加载百分比)、失败回调处理。
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath("https://s96103092003.github.io/I4B19/hw3/");
            mtlLoader.load('strts.mtl', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath("https://s96103092003.github.io/I4B19/hw3/");
                objLoader.load('strts.obj', function (object) {

                    var theObject = unitize(object, 20);
                    theObject.position.set(0, 0, 0);
                    console.log(theObject.position)
                    scene.add(theObject);
                    car = theObject;
                    console.log(car.position)
                    object.rotation.y = -Math.PI / 2;
                    theObject.traverse(function (mesh) {
                        if (mesh instanceof THREE.Mesh) {
                            mesh.material.bumpScale = 20;
                        }
                    });
                    scene.add(new THREE.BoxHelper(theObject));
                    object.traverse(function (mesh) {
                        if (mesh instanceof THREE.Mesh) {
                            mesh.material.bumpScale = 20;
                        }
                    });
                }, function (xhr) {
                    //onProgress
                    if (xhr.lengthComputable) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log(Math.round(percentComplete, 2) + '% downloaded');
                    }
                }, function (error) {
                    //onError
                    console.log("loadmtl-error: " + error);
                });

            });
        }
        function buildObstacle() {
            var texture = new THREE.Texture();
            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath("https://s96103092003.github.io/I4B19/hw3/");
            mtlLoader.load('eiffel-tower-big-ben.mtl', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath("https://s96103092003.github.io/I4B19/hw3/");
                objLoader.load('eiffel-tower-big-ben.obj', function (object) {

                    theObject.position.set(-100, 0, 0);
                    obstacle = theObject;
                    //theObject.rotation.y = rotateAngle;
                    theObject.traverse(function (mesh) {
                        if (mesh instanceof THREE.Mesh) {
                            //mesh.material.side = THREE.DoubleSide;//设置贴图模式为双面贴图
                            //mesh.material.emissive.r = 0;//设置rgb通道R通道颜色
                            //mesh.material.emissive.g = 0.01;//设置rgb通道G通道颜色
                            //mesh.material.emissive.b = 0.05;//设置rgb通道B通道颜色
                            //mesh.material.transparent = true;//材质允许透明
                            //child.material.opacity=0;//材质默认透明度                        
                            //child.material.shading=THREE.SmoothShading;//平滑渲染
                            mesh.material.bumpScale = 20;
                        }
                    });

                    scene.add(new THREE.BoxHelper(theObject));
                    scene.add(theObject);

                    object.traverse(
                        function (mesh) {
                            if (mesh instanceof THREE.Mesh) {
                                //mesh.material.side = THREE.DoubleSide;//设置贴图模式为双面贴图
                                //mesh.material.emissive.r = 0;//设置rgb通道R通道颜色
                                //mesh.material.emissive.g = 0.01;//设置rgb通道G通道颜色
                                //mesh.material.emissive.b = 0.05;//设置rgb通道B通道颜色
                                //mesh.material.transparent = true;//材质允许透明
                                //child.material.opacity=0;//材质默认透明度                        
                                //child.material.shading=THREE.SmoothShading;//平滑渲染
                                mesh.material.side = THREE.DoubleSide;
                            }
                        });
                });
            });
            var objLoader = new THREE.OBJLoader();
        }
        function unitize(object, targetSize) {

            // find bounding box of 'object'
            var box3 = new THREE.Box3();
            box3.setFromObject(object);
            var size = new THREE.Vector3();
            size.subVectors(box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar(0.5);

            // uniform scaling according to objSize
            var objSize = Math.max(size.x, size.y, size.z);
            var scaleSet = targetSize / objSize;

            var theObject = new THREE.Object3D();
            theObject.add(object);
            object.scale.set(scaleSet, scaleSet, scaleSet);
            object.position.set(-center.x * scaleSet, -center.y * scaleSet + size.y / 2 * scaleSet, -center.z * scaleSet);

            return theObject;
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera2.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camera2.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function init() {

            renderer = new THREE.WebGLRenderer({
                //antialias: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x888888);
            renderer.autoClear = false;
            //レンダラーに影描画設定追加
            document.body.appendChild(renderer.domElement);
            renderer.shadowMap.enabled = true;
            renderer.gammaInput = true;//光澤
            renderer.gammaOutput = true;

            clock = new THREE.Clock();
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 250, 40);

            camera2 = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera2.position.set(50, 10, 0);

            scene.add(camera);
            scene.add(camera2);
            //camera.position.y = 300;  // important

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls2 = new THREE.OrbitControls(camera2, renderer.domElement);

            controls.minDistance = 20;
            controls.maxDistance = 500;
            controls.enablePan = false;
            controls2.enableKeys = false;
            window.addEventListener('resize', onWindowResize, false);

            gridXZ = new THREE.GridHelper(400, 20, 'red', 'white');
            scene.add(gridXZ);
            //var spotLight = new THREE.SpotLight( hex, intensity, distance, angle, penumbra, decay );
            //光色,強度,距離,角度,半影,衰減
            spotLight = new THREE.SpotLight(0xffffff, 1);
            spotLight.position.set(30, 50, 60);

            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.05;
            spotLight.decay = 2;
            spotLight.distance = 200;

            spotLight.castShadow = true;//生成影子
            spotLight.shadow.mapSize.width = 1024;
            spotLight.shadow.mapSize.height = 1024;
            spotLight.shadow.camera.near = 10;//最短距離指定生成陰影的光源的最短距離
            spotLight.shadow.camera.far = 200;//指定生成陰影最長距離陰影的光源的最長距離。默認值是5000。


            //spotLight.shadow.camera.fov = THREE.Math.radToDeg(2 * spotLight.angle);//指定生成陰影角度陰影的光源的角度
            //spotLight.shadow.mapSize.width = spotLight.shadow.mapSize.height = 1024;//指定陰影的細度。基本上兩個將是平等的。缺省值是512。
            scene.add(spotLight);

            spotLightShadowHelper = new THREE.CameraHelper(spotLight.shadow.camera);
            scene.add(spotLightShadowHelper);

            spotLightHelper = new THREE.SpotLightHelper(spotLight);
            scene.add(spotLightHelper);
            //model = buildTank();
            //scene.add(model);
            //model.receiveShadow = true;
            buildTank();
            buildObstacle();

        }
        function update(dt) {
            keyboard.update();
            if (keyboard.pressed('A')) {
                angle += 0.02;
                console.log(angle);
            }
            else if (keyboard.pressed('D')) {
                angle -= 0.02;
                console.log(angle);
            }
            if (keyboard.pressed('W')) {
                speed += 2;
                console.log(speed);
            }
            else if (keyboard.pressed('S')) {
                speed -= 2;
                console.log(speed);
            }
            speed = Math.clamp(speed, -20, 40);

            vel = new THREE.Vector3(-speed, 0, 0);

            vel.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);//旋轉用的
            pos.add(vel.clone().multiplyScalar(dt));
        }
        function animate() {
            controls2.update();
            //controls2.update();
            spotLightHelper.update();
            spotLightShadowHelper.update();

            var dt = clock.getDelta();
            update(dt);
            //console.log("123: " + car);
            console.log("car: " + car);
            console.log("obstacle: " + obstacle);
            if (car != undefined && obstacle != undefined) {
                car.position.copy(pos);
                car.rotation.y = angle;
                //sssscamera2.rotation.y = angle;
                camera2.position.set(car.position.x + 50, 10, car.position.z);
                camera2.lookAt(car.position);
                var distance = car.position.distanceTo(obstacle.position);//距離
                if (distance < 19) {
                    speed = 0;
                }
            }

            requestAnimationFrame(animate);
            render();

        }
        function render() {
            var WW = window.innerWidth;
            var HH = window.innerHeight;


            renderer.setScissor(k, k, WW - 2 * k, HH - 2 * k);
            renderer.enableScissorTest(true);

            renderer.clear();
            camera.aspect = WW / 2 / HH;
            camera.updateProjectionMatrix();

            renderer.setViewport(0, 0, WW / 2, HH);
            renderer.render(scene, camera);

            camera2.aspect = WW / 2 / HH;
            camera2.updateProjectionMatrix();

            renderer.setViewport(WW / 2, 0, WW / 2, HH);
            renderer.render(scene, camera2);
        }

    </script>
</body>

</html>